## Lab Log

### Stage 1 - Research & Design
- Reviewed official Terraform tutorials for EKS, AKS and GKE to understand common patterns for VPC + multi-AZ + load balancer + worker nodes (Research | [Terraform EKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/eks); Research | [Terraform AKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/aks); Research | [Terraform GKE tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/gke)).  
- Reviewed the AWS EKS multi-cluster blog to understand how similar patterns are applied when applications span multiple clusters and regions (Research | [AWS EKS multi-cluster explained](https://aws.amazon.com/blogs/networking-and-content-delivery/building-resilient-multi-cluster-applications-with-amazon-eks/)).  
- Chosen a simplified target architecture: a single web “cluster” on EC2 instances spread across two Availability Zones behind an ALB, inspired by multi-AZ patterns from the Kubernetes examples.
***

### Stage 2 - GitHub Repo & Workflow
- Created a public GitHub repository `terraform-web-aws` with `main` as the stable branch and a planned set of `feature/*` branches for individual phases (project init, networking, security+EC2, ALB, modules+CI).  
- Added an initial `README.md` and a Lab Log as a living document to record design decisions and changes over time.  
- Decided to use Pull Requests for each significant change, with structured descriptions (Summary, Changes, Rationale, Testing), mirroring typical Git-based workflows in Terraform/Kubernetes projects (Process | [AWS EKS Medium article](https://medium.com/@david.e.munoz/aws-elastic-kubernetes-service-eks-e5f4c00b3781); Process | [Terraform EKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/eks)).  
***

### Stage 3 - Terraform Skeleton
- Implemented the base Terraform structure: `providers.tf`, `variables.tf`, `main.tf`, `outputs.tf` and `.gitignore`.  
- Configured the AWS provider with a parameterised `aws_region`, enabling reuse of the configuration across regions without code changes (Pattern | [Terraform EKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/eks)).  
- Ran `terraform init`, `terraform fmt` and `terraform validate` to verify configuration correctness and enforce a consistent code style, following HashiCorp’s recommendations for Terraform projects (Best practice | [Terraform EKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/eks)).  
- Opened a Pull Request **"Initialize Terraform project structure"** as the first step in a fully scripted IaC pipeline, ensuring that all subsequent infrastructure changes will be tracked, discussed and reviewed via GitHub.

### Stage 4 - Network Layer (VPC, Subnets, IGW, Routing)
- Implemented the core networking layer: one VPC (`10.0.0.0/16`), two public subnets (`10.0.1.0/24`, `10.0.2.0/24`), two private subnets (`10.0.10.0/24`, `10.0.20.0/24`) across two Availability Zones, following multi-AZ patterns used in Kubernetes/Terraform examples (Best practice | [Terraform EKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/eks); Best practice | [Terraform AKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/aks); Best practice | [Terraform GKE tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/gke)).  
- Added an Internet Gateway and a public route table with a correct default route `0.0.0.0/0`, explicitly improving on the weaker `0.0.0.0/24` example from the brief and aligning with standard AWS routing practice (Best practice | [AWS EKS multi-cluster explained](https://aws.amazon.com/blogs/networking-and-content-delivery/building-resilient-multi-cluster-applications-with-amazon-eks/)).  
- Associated public subnets with the public route table to enable internet access for future web and ALB resources in a way that is compatible with typical EKS-style architectures (Pattern | [AWS EKS Medium article](https://medium.com/@david.e.munoz/aws-elastic-kubernetes-service-eks-e5f4c00b3781)).  
- Validated the configuration using `terraform fmt`, `terraform validate`, `terraform plan` to ensure the networking layer is consistent and ready for reuse in higher layers (Best practice | [Terraform Stacks explained](https://www.hashicorp.com/en/blog/terraform-stacks-explained)).  

### Stage 5 - Security Layer, Security Groups
- Defined two Security Groups: `alb_sg` for the public Application Load Balancer and `web_sg` for the internal web EC2 instances, following a layered security model where the ALB is the only public entry point (Best practice | [AWS EKS multi-cluster explained](https://aws.amazon.com/blogs/networking-and-content-delivery/building-resilient-multi-cluster-applications-with-amazon-eks/)).  
- Allowed HTTP (80) from the internet only to the ALB, while restricting HTTP on EC2 to traffic coming from the ALB Security Group, mirroring frontend/backend separation used in many Terraform+EKS reference architectures (Pattern | [Terraform EKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/eks)).  
- Configured SSH (22) access to EC2 instances via a configurable `my_ip_cidr` variable to illustrate how administrative access can be limited to trusted sources such as a VPN or corporate IP range (Best practice | [Terraform AKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/aks); Best practice | [Terraform GKE tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/gke)).  
- Verified the configuration with `terraform fmt`, `terraform validate` and `terraform plan` to ensure the security layer is consistent and ready for attaching EC2 instances (Best practice | [Terraform Stacks explained](https://www.hashicorp.com/en/blog/terraform-stacks-explained)).  

### Stage 6 - Compute Layer (EC2 Web Cluster + user_data)
- Provisioned two Amazon Linux 2 EC2 instances (`web_a`, `web_b`) in separate public subnets across two Availability Zones to form a simple HA web cluster, using patterns similar to worker node placement in EKS-based designs (Pattern | [Terraform EKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/eks); Pattern | [AWS EKS multi-cluster explained](https://aws.amazon.com/blogs/networking-and-content-delivery/building-resilient-multi-cluster-applications-with-amazon-eks/)).  
- Attached the previously defined `web_sg` Security Group so that HTTP traffic is only allowed from the ALB and SSH access is restricted via `my_ip_cidr`, consistent with common security recommendations for web/worker nodes (Best practice | [Terraform EKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/eks)).  
- Implemented the `userdata-web.sh` script to automate instance provisioning: updating packages, installing nginx, enabling the service and rendering a custom HTML page with instance metadata (Instance ID and Availability Zone), following the idea of reproducible node bootstrapping seen in Kubernetes and Terraform examples (Pattern | [Terraform EKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/eks); Pattern | [AWS EKS Medium article](https://medium.com/@david.e.munoz/aws-elastic-kubernetes-service-eks-e5f4c00b3781)).  
- Verified the setup using `terraform fmt`, `terraform validate`, `terraform plan` and `terraform apply`, and confirmed that both instances serve the lab page over HTTP via their public IPs, which validates the end-to-end provisioning chain from IaC to running web nodes (Best practice | [Terraform Stacks explained](https://www.hashicorp.com/en/blog/terraform-stacks-explained)).  

### Stage 7 - Load Balancing (ALB + Target Group)
- Added internet-facing Application Load Balancer (`aws_lb.web_alb`) in two public subnets, using the existing `alb_sg` Security Group, following the recommended pattern of placing the load balancer in public subnets across multiple AZs (Best practice | [AWS EKS multi-cluster explained](https://aws.amazon.com/blogs/networking-and-content-delivery/building-resilient-multi-cluster-applications-with-amazon-eks/); Best practice | [Terraform EKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/eks)).  
- Created HTTP target group (`aws_lb_target_group.web_tg`) with health checks on `/` and attached both web instances (`web_a`, `web_b`) via `aws_lb_target_group_attachment`, mirroring the way worker nodes or services are grouped behind a load balancer in Kubernetes-based examples (Pattern | [Terraform EKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/eks); Pattern | [Terraform GKE tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/gke)).  
- Configured HTTP listener on port 80 to forward all incoming traffic from the ALB to the web target group, implementing classic LB -> nodes flow similar to reference architectures for EKS/AKS/GKE (Pattern | [Terraform AKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/aks); Pattern | [AWS EKS Medium article](https://medium.com/@david.e.munoz/aws-elastic-kubernetes-service-eks-e5f4c00b3781)).  
- Exposed ALB DNS name as Terraform output and verified the setup using `terraform fmt`, `terraform validate`, `terraform plan`, `terraform apply` and manual testing in a browser, confirming that traffic is distributed between instances in different Availability Zones and that the end-to-end load balancing path is working as intended (Best practice | [Terraform Stacks explained](https://www.hashicorp.com/en/blog/terraform-stacks-explained)).  


### Stage 8 - Refactor to Modules + CI
- Moved VPC, subnets, IGW and routing into a dedicated `modules/vpc` module to follow recommended modular network patterns and improve separation of concerns (Best practice | [Terraform Stacks explained](https://www.hashicorp.com/en/blog/terraform-stacks-explained); Pattern | [Terraform EKS tutorial - VPC module](https://developer.hashicorp.com/terraform/tutorials/kubernetes/eks)).
- Extracted web EC2 cluster and user_data logic into a standalone `modules/web` module, adopting the modular workload structure commonly used across EKS/AKS/GKE provisioning tutorials (Pattern | [Terraform AKS tutorial](https://developer.hashicorp.com/terraform/tutorials/kubernetes/aks); Best practice | [Terraform module structure](https://developer.hashicorp.com/terraform/language/modules/develop)).
- Created a new `modules/alb` module containing the ALB, Target Group, Listener and attachment logic, mirroring the separation used in infrastructure-as-code reference ALB modules (Pattern | [terraform-aws-alb module](https://registry.terraform.io/modules/terraform-aws-modules/alb/aws/latest); Pattern | [Terraform EKS tutorial - Load Balancers](https://developer.hashicorp.com/terraform/tutorials/kubernetes/eks)).
- Converted the root `main.tf` into a lightweight composition layer responsible only for module orchestration, high-level Security Groups, and outputs, matching modern multi-module architecture recommendations (Best practice | [Terraform Stacks explained](https://www.hashicorp.com/en/blog/terraform-stacks-explained); Pattern | [Terraform GKE tutorial - root composition](https://developer.hashicorp.com/terraform/tutorials/kubernetes/gke)).
- Introduced unified tagged `locals` (Environment, Project, Owner, Component, Tier, Role) and applied them consistently across modules, following cloud governance guidance and recommended tagging approaches (Best practice | [AWS Tagging Best Practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html); Pattern | [Terraform locals for tagging](https://developer.hashicorp.com/terraform/language/values/locals)).
- Validated modular refactor via a full plan/apply cycle: initial apply recreated resources as expected, and the subsequent re-plan produced **No changes**, confirming architecture equivalence after decomposition into modules (Best practice | [Terraform refactoring guide](https://developer.hashicorp.com/terraform/language/modules/develop/refactoring); Best practice | [Terraform plan/apply workflow](https://developer.hashicorp.com/terraform/cli/run/plan)).
